use ic_protobuf::registry::routing_table::v1::RoutingTable;
use prost::Message;
use candid::Principal;
use ic_types::CanisterId;

fn main() {
    // get_value input "routing_table"
    let _request_bytes = "routing_table".to_string().as_bytes().to_vec();
    // println!("{:?}", hex::encode(request_bytes));

    // get_value output "routing_table" 
    // error empty
    // version 28145
    // value:
    let response_hex = "0a450a201a0e0a0c0a0a00000000000000000101220e0a0c0a0a00000000000fffff010112210a1f0a1dcff280e32d7f5ccd2246882f94afb20f54ca61a21765e712d43d2789020a450a201a0e0a0c0a0a00000000001000000101220e0a0c0a0a00000000001fffff010112210a1f0a1d61b718d0b8c31db1ef09451eadd068887c1df5f37e7de0a3afc5a56a020a450a201a0e0a0c0a0a00000000002000000101220e0a0c0a0a00000000002fffff010112210a1f0a1dd77b2a2f7199b9a8aec93fe6fb588661358cf12223e9a3af7b4ebac4020a450a201a0e0a0c0a0a00000000003000000101220e0a0c0a0a00000000003fffff010112210a1f0a1dc3b96ea47e04c8977cb703f15aaf5aaaaf73d596c7be19a43a718d8b020a450a201a0e0a0c0a0a00000000004000000101220e0a0c0a0a00000000004fffff010112210a1f0a1d4164d0b890d702b3cf4f1121e504f24b0f0d94da0e935221220f3a37020a450a201a0e0a0c0a0a00000000005000000101220e0a0c0a0a00000000005fffff010112210a1f0a1dacc260d8fc5e1421c9aacc9bb5e1a1147aa15bf15304831ba734b9f8020a450a201a0e0a0c0a0a00000000006000000101220e0a0c0a0a00000000006fffff010112210a1f0a1d2c55b347ecf2686c83781d6c59d1b43e7b4cba8deb6c1b376107f2cd020a450a201a0e0a0c0a0a00000000007000000101220e0a0c0a0a00000000007fffff010112210a1f0a1d45178b66a407a4d59c0a4d6733bda2ce3f37c111b4257ec41908f4f8020a450a201a0e0a0c0a0a00000000008000000101220e0a0c0a0a00000000008fffff010112210a1f0a1d6a8f67d86ecc8307048038ad71599458c131b531dc9bb0b691940db9020a450a201a0e0a0c0a0a00000000009000000101220e0a0c0a0a00000000009fffff010112210a1f0a1d2d030caf397e446c03cece4fd072acce432c75b6a700592e73f5d133020a450a201a0e0a0c0a0a0000000000a000000101220e0a0c0a0a0000000000afffff010112210a1f0a1d30580a1a7643049513f8f7d6ffe6f51000570345a63160cab7784c59020a450a201a0e0a0c0a0a0000000000b000000101220e0a0c0a0a0000000000bfffff010112210a1f0a1d806b712f189b5651e7349743820c5f45a81592464c25048e79f25cd6020a450a201a0e0a0c0a0a0000000000c000000101220e0a0c0a0a0000000000cfffff010112210a1f0a1dfc7d15b27df96b3e98731463a2af13d6e43cf426d0cb487a71200915020a450a201a0e0a0c0a0a0000000000d000000101220e0a0c0a0a0000000000dfffff010112210a1f0a1d17f67590355e7123aeffabce4c1bddf3a0efd53a2c2e3f6228fc3adf020a450a201a0e0a0c0a0a0000000000e000000101220e0a0c0a0a0000000000efffff010112210a1f0a1d2ecc29447b0eef6c241dcfdf7dab077093ccd6a1266be0fe9c9b1276020a450a201a0e0a0c0a0a0000000000f000000101220e0a0c0a0a0000000000ffffff010112210a1f0a1d33c2f9ea0f8e2c53e6e54766dbc6cec8da6787b0154260a99925f7a8020a450a201a0e0a0c0a0a00000000010000000101220e0a0c0a0a00000000010fffff010112210a1f0a1d033a778c6c9eac039fdda83dc90d2c12eb846de85c475e36ead6715c020a450a201a0e0a0c0a0a00000000011000000101220e0a0c0a0a00000000011fffff010112210a1f0a1dba488d13a5dd7649d8093fe4897df1cc7c728ab64c856a78c4b97d6a020a450a201a0e0a0c0a0a00000000012000000101220e0a0c0a0a00000000012fffff010112210a1f0a1d5c76b3988ed788abc32d2ea13331bc29debc4f24d19a8f41417eaeb1020a450a201a0e0a0c0a0a00000000013000000101220e0a0c0a0a00000000013fffff010112210a1f0a1dfe320f2fbbb9d49c8e6edbcc9d85ec096bf645351d95bbddf556f7db020a450a201a0e0a0c0a0a00000000014000000101220e0a0c0a0a00000000014fffff010112210a1f0a1d9c7d405764f197f3611b7a6d3f7756f0c5f7a7dbb02504da09d21f29020a450a201a0e0a0c0a0a00000000015000000101220e0a0c0a0a00000000015fffff010112210a1f0a1d12790e7661fccd3d4fc83138dcaffd9f188e867b45ae10c8836dd0b8020a450a201a0e0a0c0a0a00000000016000000101220e0a0c0a0a00000000016fffff010112210a1f0a1d2f1a9548062f52ca0e90e72a4a97cb324fa1dfb62b564ef1b29f38aa020a450a201a0e0a0c0a0a00000000017000000101220e0a0c0a0a00000000017fffff010112210a1f0a1d581b5aa2f10c5f221e45de74a2cecafd3da076be39db0907cbf554bb020a450a201a0e0a0c0a0a00000000018000000101220e0a0c0a0a00000000018fffff010112210a1f0a1d10b647334a5406987796b2f8b6b14cd32f0876d3fd4fc84521058325020a450a201a0e0a0c0a0a00000000019000000101220e0a0c0a0a00000000019fffff010112210a1f0a1da22bac610f4e17278d2a0f2cf83a2e2556f6594371615940334d31d3020a450a201a0e0a0c0a0a0000000001a000000101220e0a0c0a0a0000000001afffff010112210a1f0a1dbd26ec81a3360bc8050673531b92b27988bf2a893b506f80e40c11cf020a450a201a0e0a0c0a0a0000000001b000000101220e0a0c0a0a0000000001bfffff010112210a1f0a1dbfca29efbb1f48b67849f2c9bab8a7856fd57882fb99c8ad497cf552020a450a201a0e0a0c0a0a0000000001c000000101220e0a0c0a0a0000000001cfffff010112210a1f0a1d0f033c5125db4f6b32e426268df663a5ce98fe3b531d962e1a7a87fa020a450a201a0e0a0c0a0a0000000001d000000101220e0a0c0a0a0000000001dfffff010112210a1f0a1dba58b21125381b0567e61f3f2ecd65f37710316084ee791cdfdb4a1a02";
    let response_bytes = hex::decode(response_hex).unwrap();
    
    let value = RoutingTable::decode(&response_bytes[..]).unwrap();
    // println!("{:?}", value);

    // let sub1 = Principal::from_slice(&[207, 242, 128, 227, 45, 127, 92, 205, 34, 70, 136, 47, 148, 175, 178, 15, 84, 202, 97, 162, 23, 101, 231, 18, 212, 61, 39, 137, 2]);
    // println!("{:?}", sub1.to_text());
    // let start1 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1];
    // let start_prin1 = Principal::from_slice(&start1);
    // let start_num1 = u64::from_be_bytes(start1[..8].try_into().unwrap());
    // println!("{:?}", start_prin1.to_text());
    // println!("{:?}", start_num1);


    // let end1 = [0, 0, 0, 0, 0, 15, 255, 255, 1, 1];
    // let end_prin1 = Principal::from_slice(&end1);
    // let end_num1 = u64::from_be_bytes(end1[..8].try_into().unwrap());
    // println!("{:?}", end_prin1.to_text());
    // println!("{:?}", end_num1);

    for i in value.entries.iter() {
        println!("subnet:");
        let sub = Principal::from_slice(&i.subnet_id.as_ref().unwrap().principal_id.as_ref().unwrap().raw);
        println!("{:?}", sub.to_text());

        let canister_ranges = i.range.as_ref().unwrap();
        let start = canister_ranges.start_canister_id.as_ref();
        let end = canister_ranges.end_canister_id.as_ref();
        let start_num = u64::from_be_bytes(start.unwrap().principal_id.as_ref().unwrap().raw[..8].try_into().unwrap());
        let end_num = u64::from_be_bytes(end.unwrap().principal_id.as_ref().unwrap().raw[..8].try_into().unwrap());
        let start_prin = Principal::from_slice(&start.unwrap().principal_id.as_ref().unwrap().raw);
        let end_prin = Principal::from_slice(&end.unwrap().principal_id.as_ref().unwrap().raw);

        println!("{:?}\n{:?}", start, end);
        println!("{:?}\n{:?}", start_prin.to_text(), end_prin.to_text());
        println!("{:?}\n{:?}\n", start_num, end_num);
    }

    let canister = CanisterId::from_u64(10485960);
    println!("{:?}", canister);
}